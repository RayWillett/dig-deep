<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<title>EMU Hackathon 2015</title>
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { width: 100%; height: 100% }
	</style>
</head>
<body>
<audio id = "alarm">
<source src = "aud/alarm.wav"/>
</audio>

<audio id = "shovel">
<source src = "aud/shovel.wav" type="audio/wav"/>
</audio>

<audio id = "music" autoplay loop>
<source src = "aud/music.wav"/ type="audio/wav"/>
</audio>
	<script src="js/three.min.js"></script>
	<script src="js/input.js"></script>
	<script src="js/mazeGeneration.js"></script>
	<script src="js/caveGen.js"></script>
	<script>
	var camera, scene, renderer, player, monster, input, bounds, step, moving;
	var clock = new THREE.Clock();
	
	init();
	render();
	
	function init(){
		scene = new THREE.Scene();
		//fov, aspect ratio, near, far-left
		camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
		scene.add(camera);
		camera.position.y = 6;
		
		scene.fog = new THREE.FogExp2(0x000000, 0.005);
		
		//player
		playerGeo = new THREE.BoxGeometry(4,8,4);
		playerMat = new THREE.MeshLambertMaterial();
		player = new THREE.Mesh(playerGeo, playerMat);
		player.lookAt(new THREE.Vector3(0,0,-1));
		player.position.x = 40;
		player.position.y = 2;
		player.position.z = 80;
		scene.add(player);
		player.add(camera);
		
		//hands
		geometry = new THREE.SphereGeometry(1,8,4);
		material = new THREE.MeshPhongMaterial({color:0xAA724B});
		
		handR = new THREE.Mesh(geometry, material);
		scene.add(handR);
		player.add(handR);
		handR.position.x += 3;
		handR.position.y += 2;
		handR.position.z += -8;
		
		handL = new THREE.Mesh(geometry, material);
		scene.add(handL);
		player.add(handL);
		handL.position.x += -4;
		handL.position.y += 1;
		handL.position.z += -8;
		
		//SHOVEL
		var triangleS = new THREE.Shape();
		triangleS.moveTo(0,0);
		triangleS.lineTo(4,8);
		triangleS.lineTo(12,8);
		triangleS.lineTo(8,2);
		var shovelGeo = new THREE.ShapeGeometry(triangleS);
		var shovelMat = new THREE.MeshPhongMaterial({color:0xFAFAD2});
		shovelMat.metal = true;
		var shovel = new THREE.Mesh(shovelGeo, shovelMat);
		var handleGeo = new THREE.CylinderGeometry(0.2,0.2,2);
		var handleMat = new THREE.MeshBasicMaterial({color:0x8B4513});
		var handle = new THREE.Mesh(handleGeo, handleMat);
		scene.add(shovel);
		scene.add(handle);
		
		//for collision
		//bounding box
		var bounds = new THREE.Mesh(new THREE.BoxGeometry(5,10,5), new THREE.MeshNormalMaterial({}));
		bBox = new THREE.BoundingBoxHelper(bounds, 0x00ff00);
		bBox.object.visible = false;
		scene.add(bounds);
		
		//generate things
		wallGeo = new THREE.BoxGeometry(10,30,10);
		wallMat = new THREE.MeshLambertMaterial({color:0xE393E6,shading:THREE.FlatShading});
		for(var y = 0; y < size; y++){
			for(var x = 0; x < size; x++){
				var cell = map[x][y];
				if(cell===1){
					var wall = new THREE.Mesh(wallGeo, wallMat);
					wall.position.x = x*10;
					wall.position.z = y*10;
					scene.add(wall);
				}
			}
		}
		//Ray's dungeon gen code. Would be great, but unfortunately does not work
		/*map = Dungeon.GetMap();
		wallGeo = new THREE.BoxGeometry(10,20,10);
		wallMat = new THREE.MeshLambertMaterial({color:0xE393E6});
		for(var y = 0; y < size; y++){
			for(var x = 0; x < size; x++){
				var cell = map[x][y];
				if(cell===2){
					var wall = new THREE.Mesh(wallGeo, wallMat);
					wall.position.x = x*10;
					wall.position.z = y*10;
					scene.add(wall);
				}
			}
		}*/
		
		//204,284
		var monsterGeo = new THREE.SphereGeometry();
		var monsterMat = new THREE.MeshBasicMaterial({color:0x000000});
		monster = new THREE.Mesh(monsterGeo, monsterMat);
		monster.position.x = 200;
		monster.position.z = 300;
		scene.add(monster);
		
		//floor
		tex = new THREE.CanvasTexture(generateTexture(map,256,256));
		tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
		
		floor = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000), new THREE.MeshBasicMaterial({map:tex}));
		floor.rotateX(-Math.PI/2);
		floor.position.y = -15;
		floor.position.x += 200;
		floor.position.z += 200;
		scene.add(floor);
		
		//exit generate 385,280
		var exitGeo = new THREE.BoxGeometry(5,5,5);
		var exitMat = new THREE.MeshBasicMaterial({color:0xADD8E6});
		var exit = new THREE.Mesh(exitGeo,exitMat);
		scene.add(exit);
		exit.position.x = 385;
		exit.position.y = floor.position.y;
		exit.position.z = 280;
		
		//lights
		var dirLight1 = new THREE.DirectionalLight(0xF7EFBE, 0.7);
		dirLight1.position.set(0.5, 1, 0.5);
		scene.add(dirLight1);
		var dirLight2 = new THREE.DirectionalLight(0xF7EFBE, 0.5);
		dirLight2.position.set(-0.5, -1, -0.5);
		scene.add(dirLight2);
		
		/*for(var y = 0; y < size; y++){
			for(var x = 0; x < size; x++){
				var light = new THREE.SpotLight(0xF5F5F5,100,1000);
				light.position.set(x,40,y);
				scene.add(light);
			}
		}*/
		//ui
		
		//axis helper r=x,g=y,b=z
		var axisHelper = new THREE.AxisHelper(16);
		scene.add(axisHelper);
	
		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor(0x040404);
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		
		//initialize inputs
		input = new input(player, renderer.domElement);
		input.movementSpeed = 33;
	};
	
	function update(){
		var delta = clock.getDelta();
		input.update(delta);
		bBox.object.position.x = player.position.x;
		bBox.object.position.z = player.position.z;
		bBox.update();
		step += 1;
		handL.position.setY (-(Math.sin(this.step) * 4)+2);
		handR.position.setY (Math.sin(this.step) * 18)+3;
		if(!moving){
			handL.position.y = 2;
			handR.position.y = 3;
		}
	};
	
	function render(){
		requestAnimationFrame(render);
		update();
		renderer.render(scene, camera);
	};
	
	window.addEventListener( 'resize', function () {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}, false );
	</script>
</body>
</html>